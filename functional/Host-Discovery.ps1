Import-Module $PSScriptRoot\modules\SubNet-Calculate.psm1

$startTime = Get-Date -Format "yyyy-MM-dd HH:mm"
$timeZone = (Get-TimeZone).StandardName
Write-Output "Starting ShellMap at $startTime $timeZone"

# Concept: 
# Using the ip address list generated by SubNet-Calculate.ps1 and the input arguments:
# For each ip address from the input (1+), calculate all the subnets, once the subnets are calculated, call ping through the whole list.
# Output the successfully pinged ip addresses (discovered hosts that are accessible)

### ============= FOR TESTING, USING THE USER'S IP ADDRESS: THIS IS TEMPORARY!!=================
# Get the base IP Addresses, ignoring loopback (127.0.0.1), and selecting only IPV4 (FOR NOW!!) as well as just the object IPAddress CONVERT to string
$baseAddress = (Get-NetIPAddress | Where-Object {$_.AddressFamily -eq 'IPv4' -and $_.InterfaceAlias -ne 'Loopback'} | Select-Object IPAddress)[0]

# Get the number of subnets wanted for the base address (arbitrary 24/0 for debugging)
$ipAddresses = Select-IPSubnet $baseAddress.IPAddress 0

# Store the output from the actual host discovery process in data structure to pull from later and output to user:
# HashTable -> Key = Ip/Subnet, Value = Array of objects (pingCheck, portCheck, ackCheck, timeStamp) | Format-Table (allows output to be formatted)
# (NMap done: [#IP Addresses (256)] IP addresses, ([#Hosts up] hosts up) scanned in [total ping time] seconds)
$outputTable = @{}

foreach($ipAddress in $ipAddresses)
{
    # ICMP echo request (PING): with -Quiet to do basic ping 
    # and only return output of those where ping is "Succeeded", true = reached target
    $pingCheck = Test-Connection $ipAddress -Quiet

    # Note: it is possible for host to be down but the port open since port check is separate (not whole system health)
    # TCP SYN Packet to port 443: "TCPTest Succeeded", true = open, false = closed
    $portCheck = Test-NetConnection $ipAddress -Port 433 -InformationLevel:Quiet
    
    # TCP ACK /9Test-NetConnection! (Port 80 if no port is specified!) 
### NOTE: TO ADD IF STATEMENT FOR IF THERE IS AN ARGUMENT FOR A PORT INCLUDED! CHANGE THE ACK HANDSHAKE TO THAT PORT!
    $ackCheck = Test-NetConnection $ipAddress -Port 80 -InformationLevel:Quiet
    # $ackCheck 


    # ICMP Timestamp (ROUGH ESTIMATE) Using ICMP Echo + current user's date/time

    $outputValues = [PSCustomObject]@{
        pingCheck = $pingCheck
        portCheck = $portCheck
        ackCheck = $ackCheck
    }
    # Add the outputs to the output table to be read!
    $outputTable[$ipAddress] = $outputValues
}   

###  NOTE: To fix: this formatting to actually match how I want it (below!)
$outputTable | Format-Table
Write-Output $output

# Loop the output table and display the results: THIS IS FOR DEBUGGING, THE ACTUAL OUTPUT WILL BE DONE THROUGH FORMAT-TABLE!!
foreach($outputKey in $outputTable.Keys)
{
    Write-Output "ShellMap Scan report for $outputKey"

    # Only output those where the host is up
    if($outputTable[$outputKey].pingCheck)
    {
        Write-Output "Host is up (_____ latency)." # ADD LATENCY SPEED CHECK!!
    }

    Write-Output "PORT   STATE    SERVICE"

    if($outputTable[$outputKey].portCheck)
    {
        Write-Output "433    open     "
    } else 
    {
### NOTE: How do we know how to discern fail vs filtered? How does nmap do it? Closed = no listening applications, filtered = blocked for other reasons
        Write-Output "433    filtered "
    }
### NOTE: TO ADD IF STATEMENT FOR IF THERE IS AN ARGUMENT FOR A PORT INCLUDED! CHANGE THE ACK HANDSHAKE TO THAT PORT!
    if($outputTable[$outputKey].ackCheck)
    {
        Write-Output "80    open     "
    } else 
    {
        Write-Output "80    filtered "
    }
}
